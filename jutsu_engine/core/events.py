"""
Event definitions for the Jutsu Labs backtesting engine.

This module defines all event types used in the event-driven architecture.
Events flow through the EventLoop to coordinate between modules.
"""
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Optional


class EventType(Enum):
    """Types of events in the system."""

    MARKET_DATA = "market_data"  # New bar received
    SIGNAL = "signal"  # Strategy generates buy/sell signal
    ORDER = "order"  # Order placed
    FILL = "fill"  # Order executed


@dataclass(frozen=True)
class MarketDataEvent:
    """
    Market data event containing OHLCV bar data.

    This is the primary event type fed into strategies during backtesting.
    All prices should be Decimal for financial precision.

    Attributes:
        symbol: Stock ticker symbol (e.g., 'AAPL', 'MSFT')
        timestamp: Bar timestamp (UTC timezone-aware)
        open: Opening price
        high: Highest price during period
        low: Lowest price during period
        close: Closing price
        volume: Trading volume
        timeframe: Bar period (e.g., '1D', '1H', '5m')
    """

    symbol: str
    timestamp: datetime
    open: Decimal
    high: Decimal
    low: Decimal
    close: Decimal
    volume: int
    timeframe: str = "1D"

    def __post_init__(self):
        """Validate OHLCV relationships after initialization."""
        # Validate High is highest, Low is lowest
        if not (self.low <= self.open <= self.high and self.low <= self.close <= self.high):
            raise ValueError(
                f"Invalid OHLC: H={self.high} L={self.low} O={self.open} C={self.close}"
            )

        # Validate positive prices
        if any(p <= 0 for p in [self.open, self.high, self.low, self.close]):
            raise ValueError("Prices must be positive")

        # Validate non-negative volume
        if self.volume < 0:
            raise ValueError("Volume cannot be negative")


@dataclass(frozen=True)
class SignalEvent:
    """
    Trading signal generated by a strategy.

    Represents a strategy's intent to buy or sell, but does not execute the trade.
    PortfolioSimulator processes signals and generates OrderEvents.

    Attributes:
        symbol: Stock ticker symbol
        signal_type: 'BUY', 'SELL', or 'HOLD'
        timestamp: When signal was generated
        quantity: Number of shares to trade
        portfolio_percent: Percentage of portfolio to allocate (0.0 to 1.0)
            - Decimal('0.8') represents 80% of portfolio
            - Used by Portfolio to calculate position size
            - Must be in range [0.0, 1.0]
        strategy_name: Name of strategy generating signal
        price: Optional limit price
        risk_per_share: Optional dollar risk per share for ATR-based position sizing
            - When provided, Portfolio uses: shares = (portfolio_value * portfolio_percent) / risk_per_share
            - When None, Portfolio uses: shares = (portfolio_value * portfolio_percent) / price
            - Must be positive if provided
            - Typical value: ATR * stop_multiplier (e.g., $2.50 * 2.0 = $5.00)
    """

    symbol: str
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    timestamp: datetime
    quantity: int
    portfolio_percent: Decimal
    strategy_name: str = "unknown"
    price: Optional[Decimal] = None  # Limit price (optional)
    risk_per_share: Optional[Decimal] = None  # ATR-based risk per share (optional)

    def __post_init__(self):
        """Validate signal parameters."""
        if self.signal_type not in ['BUY', 'SELL', 'HOLD']:
            raise ValueError(f"Invalid signal type: {self.signal_type}")

        if self.quantity <= 0:
            raise ValueError(f"Quantity must be positive: {self.quantity}")

        # Validate portfolio_percent range
        if not (Decimal('0.0') <= self.portfolio_percent <= Decimal('1.0')):
            raise ValueError(
                f"Portfolio percent must be between 0.0 and 1.0, got {self.portfolio_percent}"
            )

        # Validate risk_per_share if provided
        if self.risk_per_share is not None:
            if self.risk_per_share <= Decimal('0.0'):
                raise ValueError(
                    f"risk_per_share must be positive, got {self.risk_per_share}"
                )


@dataclass(frozen=True)
class OrderEvent:
    """
    Order placed by portfolio simulator.

    Represents an actual order to be executed. Generated by PortfolioSimulator
    in response to SignalEvent.

    Attributes:
        symbol: Stock ticker symbol
        order_type: 'MARKET', 'LIMIT'
        direction: 'BUY' or 'SELL'
        quantity: Number of shares
        timestamp: When order was placed
        price: Limit price (for LIMIT orders)
    """

    symbol: str
    order_type: str  # 'MARKET', 'LIMIT'
    direction: str  # 'BUY', 'SELL'
    quantity: int
    timestamp: datetime
    price: Optional[Decimal] = None  # For limit orders

    def __post_init__(self):
        """Validate order parameters."""
        if self.order_type not in ['MARKET', 'LIMIT']:
            raise ValueError(f"Invalid order type: {self.order_type}")

        if self.direction not in ['BUY', 'SELL']:
            raise ValueError(f"Invalid direction: {self.direction}")

        if self.quantity <= 0:
            raise ValueError(f"Quantity must be positive: {self.quantity}")

        if self.order_type == 'LIMIT' and self.price is None:
            raise ValueError("LIMIT orders require a price")


@dataclass(frozen=True)
class FillEvent:
    """
    Order execution event (fill).

    Generated when an order is executed. Contains actual execution details
    including price, commission, and slippage.

    Attributes:
        symbol: Stock ticker symbol
        direction: 'BUY' or 'SELL'
        quantity: Number of shares executed
        fill_price: Actual execution price
        timestamp: Execution timestamp
        commission: Trading commission paid
        slippage: Difference from expected price
    """

    symbol: str
    direction: str  # 'BUY', 'SELL'
    quantity: int
    fill_price: Decimal
    timestamp: datetime
    commission: Decimal = Decimal('0.00')
    slippage: Decimal = Decimal('0.00')

    def __post_init__(self):
        """Validate fill parameters."""
        if self.direction not in ['BUY', 'SELL']:
            raise ValueError(f"Invalid direction: {self.direction}")

        if self.quantity <= 0:
            raise ValueError(f"Quantity must be positive: {self.quantity}")

        if self.fill_price <= 0:
            raise ValueError(f"Fill price must be positive: {self.fill_price}")

    @property
    def total_cost(self) -> Decimal:
        """Calculate total cost including commission and slippage."""
        base_cost = self.quantity * self.fill_price
        return base_cost + self.commission + self.slippage
